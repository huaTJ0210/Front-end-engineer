<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      // (1) 创建空代理对象
      /*
      let target = { // 目标对象
        name: 'li',
      };
      let handler = {}; // 处理程序对象
      let proxy = new Proxy(target, handler); // 空代理对象
      // 代理对象上执行的操作都会反应在目标对象上
      proxy.name = 'shan';
      console.log(target.name);
      target.name = 'zhang';
      console.log(proxy.name);
      */

      // (2) 定义捕获器
      /*
      let target = {
        // 目标对象
        name: 'li'
      };
      let handler = {
        // 捕获器
        get(trapTarget, property, receiver) {
          console.log(trapTarget === target);
          console.log(property);
          console.log(receiver === proxy);
          return 'handler override';
        },
      }; // 处理程序对象
      let proxy = new Proxy(target, handler); // 空代理对象
      console.log(proxy.name);
      */

      // (3) 在捕获器中调用目标对象的原始行为
      /*
      let target = {
        // 目标对象
        name: 'li',
      };
      let handler = {
        // 捕获器
        get() {
          // 重新调用目标对象上的原始行为
          return Reflect.get(...arguments);
        },
      }; // 处理程序对象
      let proxy = new Proxy(target, handler); // 空代理对象
      console.log(proxy.name);
      */

      // (4) 可撤销代理
      let target = {
        // 目标对象
        name: 'li',
      };
      let handler = {
        // 捕获器
        get() {
          // 重新调用目标对象上的原始行为
          return Reflect.get(...arguments);
        },
      }; // 处理程序对象
     const {proxy,revoke} = Proxy.revocable(target,handler);
     revoke();// 调用此函数就可以撤销目标对象与代理对象之间的关联

    </script>
  </head>
  <body></body>
</html>
